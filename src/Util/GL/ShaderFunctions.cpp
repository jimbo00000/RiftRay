// ShaderFunctions.cpp

#ifdef _WIN32
#  define WINDOWS_LEAN_AND_MEAN
#  define NOMINMAX
#  include <windows.h> // malloc, free
#endif

#include <stdio.h>
#include <string.h>
#include <assert.h>

#include <string>
#include <iostream>
#include <fstream>
#include <sstream>

#include <GL/glew.h>

#include "ShaderFunctions.h"

#if 1
#include "g_shaders.h"
#else
#include <map>
std::map<std::string, std::string> g_shaderMap;
void initShaderList() {}
#endif

// Got this from http://www.lighthouse3d.com/opengl/glsl/index.php?oglinfo
// it prints out shader info (debugging!)
void printShaderInfoLog(GLuint obj)
{
    int infologLength = 0;
    int charsWritten  = 0;
    char *infoLog;
    glGetShaderiv(obj, GL_INFO_LOG_LENGTH, &infologLength);
    if (infologLength > 1)
    {
        infoLog = new char[infologLength];
        glGetShaderInfoLog(obj, infologLength, &charsWritten, infoLog);
        std::cout << std::endl << infoLog << std::endl;
        delete [] infoLog;
    }
    else if (obj == 0)
    {
        std::cout << " NOT FOUND" << std::endl;
    }
    else std::cout << "OK ";
}

// Got this from http://www.lighthouse3d.com/opengl/glsl/index.php?oglinfo
// it prints out shader info (debugging!)
void printProgramInfoLog(GLuint obj)
{
    int infologLength = 0;
    int charsWritten  = 0;
    char *infoLog;
    glGetProgramiv(obj, GL_INFO_LOG_LENGTH, &infologLength);
    if (infologLength > 1)
    {
        infoLog = new char[infologLength];
        glGetProgramInfoLog(obj, infologLength, &charsWritten, infoLog);
        std::cout << std::endl << infoLog << std::endl;
        delete [] infoLog;
    }
    else std::cout << "OK ";
}

std::string slurp(std::ifstream& in)
{
    std::stringstream sstr;
    sstr << in.rdbuf();
    return sstr.str();
}

/// Return the contents of a given filename in the ../shaders/ directory.
const std::string GetShaderSourceFromFile(const char* filename, const std::string path)
{
    std::cout << "<<file>> ";

    std::string shaderName = filename;
    std::string fullShaderName = path + shaderName; ///@todo Check parent paths

    std::ifstream file;
    file.open(fullShaderName.c_str(), std::ios::in);
    if (!file.is_open())
    {
        std::cerr << "No file " << filename << std::endl;
        return "";
    }

    std::string fileContents = slurp(file);
    file.close();

    return fileContents;
}

/// Retrieve shader source from a std::map of hard-coded shaders generated by
/// shader_hardcoder.py to the file shaderlist.h.
/// @note Memory is allocated using new, delete [] it when done.
const GLchar* GetShaderSourceFromTable(const char* filename)
{
    std::cout << "  <<table>> ";

    if (g_shaderMap.empty())
    {
        initShaderList();
    }

    if (g_shaderMap.count(filename) > 0)
    {
        const std::string& src = g_shaderMap[filename];
        GLchar* GLsrc = new char[src.length()+1]; // include null terminator
        memcpy(GLsrc, src.c_str(), src.length()+1);
        return GLsrc;
    }
    else
    {
        std::cout << "No entry " << filename;
    }

    return NULL;
}

/// Return shader source from filename, if it can be retrieved.
/// If not, fall back to the hard-coded array in our global std::map.
const std::string GetShaderSource(const char* filename)
{
#ifdef _LINUX
    /// Linux exhibits odd behavior when loading shader from file - trailing
    /// garbage characters in the shader source string.
    ///@todo Why does loading shaders in Linux yield extra garbage characters?
    const std::string fileSrc = "";
//#elif defined(_MACOS)
//    const std::string fileSrc = "";
#else
    const std::string fileSrc = GetShaderSourceFromFile(filename);
#endif
    if (!fileSrc.empty())
        return fileSrc;

    const GLchar* pSrc = GetShaderSourceFromTable(filename);
    if (pSrc != NULL)
        return pSrc;

    return "";
}

/// Once source is obtained from either file or hard-coded map, compile the
/// shader, release the string memory and return the ID.
GLuint loadShaderFile(const char* filename, const unsigned long Type)
{
    if (filename == NULL)
        return 0;
    const std::string shaderSource = GetShaderSource(filename);
    std::string sourceString(shaderSource);

    if (sourceString.empty())
        return 0;
    GLint length = static_cast<GLint>(sourceString.length());

    GLuint shaderId = glCreateShader(Type);
    const GLchar* pSrcStr = sourceString.c_str();
    glShaderSource(shaderId, 1, &pSrcStr, &length);
    glCompileShader(shaderId);

    return shaderId;
}

GLuint makeShaderFromSource(
    const char* vert,
    const char* frag,
    const char* geom)
{
    std::cout << "  vs-";
    GLuint vertSrc = loadShaderFile(vert, GL_VERTEX_SHADER);
    printShaderInfoLog(vertSrc);

    std::cout << "  fs-";
    GLuint fragSrc = loadShaderFile(frag, GL_FRAGMENT_SHADER);
    printShaderInfoLog(fragSrc);

    // Vertex and fragment shaders are required
    if ((vertSrc == 0) || (fragSrc == 0))
    {
        std::cout << "  SHADER NOT COMPILED - source not found." << std::endl;
        return 0;
    }

    //std::cout << "  gs: ";
    GLuint geomSrc = loadShaderFile(geom, GL_GEOMETRY_SHADER_EXT);

    GLuint program = glCreateProgram();

    glCompileShader(vertSrc);
    glCompileShader(fragSrc);

    GLint success = 0;
    glGetShaderiv(vertSrc, GL_COMPILE_STATUS, &success);
    assert(success == GL_TRUE);
    glGetShaderiv(fragSrc, GL_COMPILE_STATUS, &success);
    assert(success == GL_TRUE);

    glAttachShader(program, vertSrc);
    glAttachShader(program, fragSrc);

    // Will be deleted when program is.
    glDeleteShader(vertSrc);
    glDeleteShader(fragSrc);

    // Initialize Geometry shader state after creation, before linking.
    if (geomSrc)
    {
        std::cout << "  gs-";
        printShaderInfoLog(geomSrc);
        glCompileShader(geomSrc);
        glAttachShader (program, geomSrc);
    }

    glLinkProgram(program);
    std::cout << "  prog: ";
    printProgramInfoLog(program);

    std::cout << std::endl;

    glUseProgram(0);
    return program;
}

/// Append any applicable suffixes to the name given and attempt to find
/// vertex, fragment and (optionally) geometry shader source.
GLuint makeShaderByName(const char* name)
{
    if (!name)
        return 0;

    std::string vs(name);
    std::string fs(name);
    std::string gs(name);
    vs += ".vert";
    fs += ".frag";
    gs += ".geom";

    std::cout << std::endl
        << "makeShaderByName("
        << vs
        << ", "
        << fs
        << ", "
        << gs
        << "):__"
        << std::endl;

    return makeShaderFromSource(vs.c_str(), fs.c_str(), gs.c_str());
}
